// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: prepaid_products.sql

package database

import (
	"context"
)

const deleteAllPrepaidProducts = `-- name: DeleteAllPrepaidProducts :exec
DELETE FROM prepaid_products
`

func (q *Queries) DeleteAllPrepaidProducts(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteAllPrepaidProductsStmt, deleteAllPrepaidProducts)
	return err
}

const getBrandsByCategory = `-- name: GetBrandsByCategory :many
SELECT DISTINCT brand
FROM prepaid_products
WHERE category = ?
`

func (q *Queries) GetBrandsByCategory(ctx context.Context, category string) ([]string, error) {
	rows, err := q.query(ctx, q.getBrandsByCategoryStmt, getBrandsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var brand string
		if err := rows.Scan(&brand); err != nil {
			return nil, err
		}
		items = append(items, brand)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategories = `-- name: GetCategories :many
SELECT DISTINCT category
FROM prepaid_products
`

func (q *Queries) GetCategories(ctx context.Context) ([]string, error) {
	rows, err := q.query(ctx, q.getCategoriesStmt, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var category string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrepaidProductBySKUCode = `-- name: GetPrepaidProductBySKUCode :one
SELECT 
  id,
  name,
  seller_name,
  price,
  buyer_sku_code,
  buyer_product_status,
  seller_product_status,
  description
FROM prepaid_products
WHERE buyer_sku_code = ? COLLATE NOCASE
LIMIT 1
`

type GetPrepaidProductBySKUCodeRow struct {
	ID                  int64
	Name                string
	SellerName          string
	Price               int64
	BuyerSkuCode        string
	BuyerProductStatus  bool
	SellerProductStatus bool
	Description         *string
}

func (q *Queries) GetPrepaidProductBySKUCode(ctx context.Context, buyerSkuCode string) (*GetPrepaidProductBySKUCodeRow, error) {
	row := q.queryRow(ctx, q.getPrepaidProductBySKUCodeStmt, getPrepaidProductBySKUCode, buyerSkuCode)
	var i GetPrepaidProductBySKUCodeRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SellerName,
		&i.Price,
		&i.BuyerSkuCode,
		&i.BuyerProductStatus,
		&i.SellerProductStatus,
		&i.Description,
	)
	return &i, err
}

const getPrepaidProducts = `-- name: GetPrepaidProducts :many
SELECT
  pp.name,
  pp.buyer_sku_code,
  pp.price,
  pp.seller_name,
  pp.buyer_product_status,
  pp.seller_product_status
FROM prepaid_products pp
WHERE pp.category = ?
  AND pp.brand = ?
  AND pp.type = ?
ORDER BY pp.price ASC
`

type GetPrepaidProductsParams struct {
	Category string
	Brand    string
	Type     string
}

type GetPrepaidProductsRow struct {
	Name                string
	BuyerSkuCode        string
	Price               int64
	SellerName          string
	BuyerProductStatus  bool
	SellerProductStatus bool
}

func (q *Queries) GetPrepaidProducts(ctx context.Context, arg *GetPrepaidProductsParams) ([]*GetPrepaidProductsRow, error) {
	rows, err := q.query(ctx, q.getPrepaidProductsStmt, getPrepaidProducts, arg.Category, arg.Brand, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPrepaidProductsRow{}
	for rows.Next() {
		var i GetPrepaidProductsRow
		if err := rows.Scan(
			&i.Name,
			&i.BuyerSkuCode,
			&i.Price,
			&i.SellerName,
			&i.BuyerProductStatus,
			&i.SellerProductStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypesByCategoryAndBrand = `-- name: GetTypesByCategoryAndBrand :many
SELECT DISTINCT type
FROM prepaid_products
WHERE category = ? AND brand = ?
`

type GetTypesByCategoryAndBrandParams struct {
	Category string
	Brand    string
}

func (q *Queries) GetTypesByCategoryAndBrand(ctx context.Context, arg *GetTypesByCategoryAndBrandParams) ([]string, error) {
	rows, err := q.query(ctx, q.getTypesByCategoryAndBrandStmt, getTypesByCategoryAndBrand, arg.Category, arg.Brand)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var type_ string
		if err := rows.Scan(&type_); err != nil {
			return nil, err
		}
		items = append(items, type_)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPrepaidProduct = `-- name: InsertPrepaidProduct :exec
INSERT INTO prepaid_products (
  name, 
  category, 
  brand, 
  type, 
  seller_name, 
  price,
  buyer_sku_code, 
  buyer_product_status, 
  seller_product_status,
  unlimited_stock,
  stock,
  multi,
  start_cut_off,
  end_cut_off,
  description
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertPrepaidProductParams struct {
	Name                string
	Category            string
	Brand               string
	Type                string
	SellerName          string
	Price               int64
	BuyerSkuCode        string
	BuyerProductStatus  bool
	SellerProductStatus bool
	UnlimitedStock      bool
	Stock               int64
	Multi               bool
	StartCutOff         *string
	EndCutOff           *string
	Description         *string
}

func (q *Queries) InsertPrepaidProduct(ctx context.Context, arg *InsertPrepaidProductParams) error {
	_, err := q.exec(ctx, q.insertPrepaidProductStmt, insertPrepaidProduct,
		arg.Name,
		arg.Category,
		arg.Brand,
		arg.Type,
		arg.SellerName,
		arg.Price,
		arg.BuyerSkuCode,
		arg.BuyerProductStatus,
		arg.SellerProductStatus,
		arg.UnlimitedStock,
		arg.Stock,
		arg.Multi,
		arg.StartCutOff,
		arg.EndCutOff,
		arg.Description,
	)
	return err
}
